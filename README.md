## Description ##

Get_next_line is a function used to read from a file descriptor line by line.
Its existence is due to the common need for programs or functions to process input one line at a time. For example, a program may need to read a file line by line in order to build a map or parse structured data.

This function guarantees that lines can be read until the read operation fails or until the end of file (EOF) is reached.
Each call to the function returns one line, including the newline character (\n) if it exists.

If the function is called once, it returns the first line of the file descriptor.
If it is called twice, it returns the first two lines, and so on.

Get_next_line can operate on any valid file descriptor, including standard input (stdin), which corresponds to file descriptor 0. The same applies to other file descriptors, typically ranging from 3 to 1023.

The bonus part of the project follows the same principles but extends the implementation to handle multiple file descriptors simultaneously, ensuring that each file descriptor maintains its own reading state.

## Instructions ##

To use this function in another file, the user must include the provided source files in the compilation process.
A file descriptor is first obtained by calling the open function on a file, using the O_RDONLY flag, and storing the returned value in a variable of type int. This file descriptor is then passed as the only parameter to get_next_line.

If the user creates an external file (for example, main.c) to test the function, that file must also be compiled along with the project files.

Compilation example:

cc -Wall -Werror -Wextra <main.c (optional)> get_next_line.c get_next_line_utils.c


For the bonus version:

cc -Wall -Werror -Wextra <main.c (optional)> get_next_line_bonus.c get_next_line_utils_bonus.c


The project also uses a macro called BUFFER_SIZE, which defines how many bytes are read during each call to read. This value can be changed at compilation time by using the -D flag.

Example:

cc -Wall -Werror -Wextra -D BUFFER_SIZE=42 <main.c (optional)> get_next_line.c get_next_line_utils.c


Changing this macro allows the user to control how many bytes are read per iteration of the function.

## Resources ##

My main external resource was GeeksForGeeks, particularly the article about static variables in C, which helped me understand what static variables are and why they are essential for this project:

Static variables in C (GeeksForGeeks)

Additionally, discussions with my peers were extremely valuable. Their feedback and explanations helped me better understand edge cases and refine my implementation.

AI was used as a support tool to:

Suggest clearer names for functions and variables

Help correct spelling and punctuation errors in this README

No code was directly generated by AI.

## Algorithm explanation ##

The core idea of this project relies on the use of a static variable to store data that persists between function calls.
Static variables are allocated in a special memory area (the data or BSS segment) and retain their value for the entire duration of the program. This makes them ideal for preserving unread data between successive calls to get_next_line.

The function works by repeatedly reading from the file descriptor in chunks of BUFFER_SIZE bytes and storing this data in a persistent buffer. The reading process continues until either a newline character (\n) is found or the end of file is reached.

At a high level, the algorithm follows these steps:

Read from the file descriptor
The function reads BUFFER_SIZE bytes from the file descriptor and appends them to a static buffer that may already contain leftover data from a previous call.

Check for a complete line
If the buffer contains a newline character, a complete line can be extracted. If not, the function continues reading until a newline is found or read returns 0 (EOF).

Extract the line
A helper function is used to allocate and build the line to be returned, copying characters from the buffer up to and including the newline character (if present).

Preserve remaining data
After extracting the line, another helper function removes the processed portion from the buffer and shifts any remaining, unprocessed data to the beginning. This ensures that no data is lost and that the next call to get_next_line continues exactly where the previous one stopped.

Handle edge cases

If EOF is reached and the buffer still contains data, that data is returned as the last line.

If read fails or there is no data left to process, the function returns NULL.

This approach avoids rereading data from the file descriptor and ensures efficient, sequential access to the file contents.
In the bonus version, the same logic is applied, but a separate static buffer is maintained for each file descriptor, allowing multiple files to be read independently and correctly.